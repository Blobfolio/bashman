/*!
# Cargo BashMan: Target Triples.
*/

#![expect(clippy::too_many_lines, reason = "Rust has a lot of targets!")]

use crate::BashManError;
use oxford_join::JoinFmt;
use std::{
	borrow::Cow,
	collections::BTreeSet,
	ffi::OsStr,
	fmt,
	process::{
		Command,
		Stdio,
	},
};

// Generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/target-triples.rs"));

impl TargetTriple {
	/// # Print Possibilities.
	///
	/// This is used by `BashManError::PrintTargets` to emit a list of all
	/// supported target triples.
	///
	/// As our compile-time list may not match the local `rustc`, only targets
	/// supported by _both_ will be reported.
	pub(crate) fn print(f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
		// Collect the targets we support, i.e. what our version of rustc
		// supported at the time this package was last built.
		let mut all: BTreeSet<&str> = Self::all().map(Self::as_str).collect();

		// If the user has rustc on their system — they should! — see what it
		// supports as it might be different. (We'll want to print the
		// intersection in such cases.)
		if let Some(real) = rustc_targets() {
			let other: BTreeSet<&str> = real.lines()
				.filter_map(|line| {
					let line = line.trim();
					if line.is_empty() { None }
					else { Some(line) }
				})
				.collect();

			// Remove anything from our list that other doesn't know about.
			all.retain(|t| other.contains(t));
		}

		// Print them!
		write!(f, "{}", JoinFmt::new(all.into_iter(), "\n"))
	}
}



/// # Actual Rustc Triples.
///
/// We support what we support, but the native rustc might have its own ideas.
/// Query it if possible so we can compare and contrast.
fn rustc_targets() -> Option<String> {
	Command::new({
		let out = std::env::var_os("RUSTC").unwrap_or_default();
		if out.is_empty() { Cow::Borrowed(OsStr::new("rustc")) }
		else { Cow::Owned(out) }
	})
		.args(["--print", "target-list"])
		.stdin(Stdio::null())
		.stdout(Stdio::piped())
		.stderr(Stdio::null())
		.output()
		.ok()
		.and_then(|o|
			if o.status.success() {
				String::from_utf8(o.stdout).ok().filter(|s| s.contains("aarch64-"))
			}
			else { None }
		)
}
